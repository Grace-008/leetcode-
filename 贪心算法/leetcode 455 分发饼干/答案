这个问题是一个贪心算法问题。我们的目标是尽可能满足更多的孩子，所以我们应该优先给胃口小的孩子分配饼干，这样就更可能有更多的饼干能够满足其他孩子。

这个算法首先对孩子们的胃口值和饼干的尺寸进行排序，然后从最小的胃口值和饼干尺寸开始尝试分配。

如果一块饼干可以满足一个孩子，那么就将这块饼干分配给这个孩子，然后考虑下一个孩子和饼干。

如果一块饼干不能满足一个孩子，那么就舍弃这块饼干，然后考虑下一块饼干。这样就可以保证每个孩子都得到的饼干尺寸是他可以接受的，并且从总体上尽可能多的孩子得到了饼干。

贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法。

在这个问题中，贪心算法的体现在于我们总是尽可能地满足胃口最小的孩子。这是因为胃口小的孩子更容易被满足，所以我们先尝试满足他们，这样可以留下更大的饼干去尝试满足胃口大的孩子，从而使得尽可能多的孩子都能得到饼干。这种每次选择当前最优解的思路就是贪心思想。

如果我们没有按照这个策略，而是随机地或者先给胃口大的孩子分配饼干，那么可能会出现饼干不够分的情况，因为大饼干可以满足胃口小的孩子，但小饼干不能满足胃口大的孩子。所以，按照胃口大小排序并优先满足胃口小的孩子，就体现了贪心的思想。


def findContentChildren(g, s):
    g.sort()
    s.sort()

    child_i = cookie_j = 0
    # 当任意一个数组完成遍历，我们就结束分配
    while child_i < len(g) and cookie_j < len(s):
        if s[cookie_j] >= g[child_i]:  # 如果这块饼干能满足这个孩子
            child_i += 1  # 饼干分配给这个孩子
        cookie_j += 1  # 不论是否满足，我们都需要将这块饼干拿出去尝试分配

    return child_i  # 返回满足的孩子数量
