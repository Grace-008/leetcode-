#与leetcode 327相似

class Solution:
    def reversePairs(self, nums: List[int]) -> int:
        temp= [0]*len(nums)
        return self.mergeSort(nums,0,len(nums)-1,temp)

    def mergeSort(self, nums, lo, hi, temp):
        if lo >= hi:
            return 0
        mid = lo + (hi - lo) // 2
        #在合并之前就有计算区间和
        leftSumCount = self.mergeSort(nums, lo, mid, temp)
        rightSumCount = self.mergeSort(nums, mid+1, hi, temp)
        count = 0
        #计算当前翻转对的个数
        i = lo
        j = mid+1
        while i<=mid:
            while j<=hi and nums[i]>(2*nums[j]):
                j+=1
            count+=(j-mid-1)
            i+=1

            
        self.merge(nums, lo, mid, hi, temp)
        return leftSumCount + rightSumCount + count

    def merge(self, nums, lo, mid, hi, temp):
        for i in range(lo, hi+1):
            temp[i] = nums[i]
        i, j = lo, mid+1
        for k in range(lo, hi+1):
            if i > mid:
                nums[k] = temp[j]
                j += 1
            elif j > hi:
                nums[k] = temp[i]
                i += 1
            elif temp[i] <= temp[j]:
                nums[k] = temp[i]
                i += 1
            else:
                nums[k] = temp[j]
                j += 1
