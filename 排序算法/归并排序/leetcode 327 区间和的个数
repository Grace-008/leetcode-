⭕️暴力解法

class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        count=0
        for i in range(len(nums)):
            for j in range(i,len(nums)):
                sum=0
                for k in range(i,j+1):
                    sum+=nums[k]
                if sum<=upper and sum>=lower:
                    count+=1
        return count


⭕️前缀和
class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        prefixSum = [0]*(len(nums)+1)
        prefixSum[0]=0
        for i in range(len(nums)):
            prefixSum[i+1]=prefixSum[i]+nums[i]

        count=0
        for i in range(len(prefixSum)):
            for j in range(i+1,len(prefixSum)):
                sum=prefixSum[j]-prefixSum[i]
                if sum<=upper and sum>=lower:
                    count+=1
        return count
        
 ⭕️归并排序
 ▶️查找【i，j】使prefixSum[j]-prefixSum[i]属于【lower,upper】
 其中i < j
 
from typing import List

class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        sums = [0] * (len(nums) + 1)
        for i, num in enumerate(nums):
            sums[i + 1] = sums[i] + num
        
        return self.merge_sort(sums, lower, upper, 0, len(sums))

    def merge_sort(self, sums: List[int], lower: int, upper: int, lo: int, hi: int) -> int:
        if hi - lo <= 1:
            return 0
        
        mid = (lo + hi) // 2
        count = self.merge_sort(sums, lower, upper, lo, mid) + self.merge_sort(sums, lower, upper, mid, hi)
        i, j = mid, mid
        
        for left in range(lo, mid):
            while i < hi and sums[i] - sums[left] < lower:
                i += 1
            while j < hi and sums[j] - sums[left] <= upper:
                j += 1
            count += j - i
        
        sums[lo:hi] = sorted(sums[lo:hi])
        return count


---------完整版-------

class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        sums = [0] * (len(nums) + 1)
        for i, num in enumerate(nums):
            sums[i+1] = sums[i] + num

        return self.merge_sort(sums, lower, upper, 0, len(nums))

    def merge_sort(self, sums, lower, upper, lo, hi):
        if hi <= lo:
            return 0

        mid = lo + (hi - lo) // 2

        count = self.merge_sort(sums, lower, upper, lo, mid) + self.merge_sort(sums, lower, upper, mid+1, hi)

        left = sums[lo:mid+1]
        right = sums[mid+1:hi+1]

        i = j = 0
        for val in left:
            while i < len(right) and right[i] - val < lower:
                i += 1

            while j < len(right) and right[j] - val <= upper:
                j += 1

            count += j - i

        i = j = 0
        k = lo

        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                sums[k] = left[i]
                i += 1
            else:
                sums[k] = right[j]
                j += 1

            k += 1

        while i < len(left):
            sums[k] = left[i]
            i += 1
            k += 1

        while j < len(right):
            sums[k] = right[j]
            j += 1
            k += 1

        return count

