1.如何写一个通用的排序算法

http://www.x-lab.info/post/sort-algorithm/

1.1 O(n**2)排序算法的选择
▶️插入排序性能最好，其次是选择排序，冒泡排序性能最差
▶️对于大规模的乱序数组的排序，可以使用希尔排序

1.2 O(nlog)排序算法的选择
▶️快排时间复杂度最差情况下是O(n^2)，合理选择分区点
▶️归并排序在任何情况下的时间复杂度都是O(nlog)
▶️归并排序的空间复杂度是O(n)，快排空间复杂度O(logn)
▶️快排不是稳定的排序算法，归并是稳定的排序算法

1.3O(n)排序算法的选择
▶️对输入数据要求苛刻
▶️桶排序，桶和桶之间有序，元素均匀地划分到桶中
▶️计数排序，应用在数据范围不大的场景
▶️基数排序，排序数据可以分割出独立的位

1.4O(n**2)排序算法对比O(nlog)排序算法
归并排序的时间复杂度 cn+logn
O(n**2)排序算法的时间复杂度 1/2*n^2-3/2*n+1
▶️结论：小规模数据，使用O(n**2)排序算法；大规模数据，使用O(nlog)排序算法

1.5如何写一个通用的排序算法
▶️不能选择线性时间复杂度的桶排序，计数排序，基数排序
▶️小规模数据，可以使用O(n**2)排序算法
▶️大规模数据，使用O(nlog)排序算法

data = [34, 33, 12, 78, 21, 1, 98, 100]
#通用的排序
#对于小数据量（小于47），使用插入排序
#让后小数据量（大于47而小于286）的话使用递归实现的快速排序
#对于大数据量使用迭代（自底朝上）实现的归并排序（递归有可能因为栈太深，导致内存溢出）
data.sort() 
print(data)


2.排序元素比较




3.分治算法思想

