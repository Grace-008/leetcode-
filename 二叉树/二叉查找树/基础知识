▶️
二叉查找树（Binary Search Tree，简称BST）是一种特殊的二叉树，它满足以下性质：

左子树上所有节点的值均小于它的根节点的值。
右子树上所有节点的值均大于它的根节点的值。
左右子树也分别为二叉查找树。

▶️
二叉查找树的特点如下：

左子树上所有节点的值均小于它的根节点的值，右子树上所有节点的值均大于它的根节点的值。
中序遍历结果是一个升序序列，因此可以用来实现快速的查找、插入和删除操作。
左右子树也分别为二叉查找树，因此可以用递归的方式进行操作。
如果二叉查找树的左右子树高度差过大，它的插入、查找和删除操作的时间复杂度可能会退化到O(n)，其中n为二叉查找树中节点的数量。

▶️
AVL树是一种自平衡二叉查找树，它的命名来源于它的发明者 Georgy Adelson-Velsky 和 Evgenii Landis。

AVL树满足以下性质：

对于任意一个节点，它的左子树和右子树的高度差（即平衡因子）的绝对值不超过1。
左子树和右子树都是AVL树。
AVL树的平衡通过旋转操作来实现。当一个节点的左子树和右子树的高度差超过1时，需要进行旋转操作来平衡二叉树。

AVL树旋转操作包括以下四种：

左旋操作：对于一个节点的左子树高度大于右子树高度的情况，进行左旋操作。
右旋操作：对于一个节点的右子树高度大于左子树高度的情况，进行右旋操作。
左右旋操作：对于一个节点的左子树的右子树高度大于它的左子树的左子树高度的情况，进行左右旋操作。
右左旋操作：对于一个节点的右子树的左子树高度大于它的右子树的右子树高度的情况，进行右左旋操作。
AVL树的插入、删除、查找等操作的时间复杂度为O(log n)，其中n为AVL树中节点的数量。

AVL树相对于其他平衡树，例如红黑树等，具有平衡更加严格、查找性能更优等优点。但是由于每个节点都需要存储平衡因子，因此它的空间复杂度更高。

▶️
2-3查找树是一种自平衡的树形数据结构，用于实现符号表的数据结构，它满足以下特点：

每个节点都包含1个或2个键（key）和相应的值（value）。
如果一个节点包含1个键，则它有两个子节点，左子节点的键小于该节点的键，右子节点的键大于该节点的键。
如果一个节点包含2个键，则它有三个子节点，左子节点的键小于该节点的第一个键，中间子节点的键介于该节点的两个键之间，右子节点的键大于该节点的第二个键。
所有叶子节点都在同一层次上，即树的高度为O(log n)，其中n为节点数。
所有的2-节点（节点包含1个键）都会和它的兄弟节点合并，形成3-节点（节点包含2个键），以维护平衡。
2-3查找树中的每个节点可以表示一个区间，一个节点包含1个键时，表示的是该键所对应的区间；一个节点包含2个键时，表示的是该节点所对应的两个键所夹的区间。

2-3查找树支持快速的查找、插入、删除等操作，其时间复杂度为O(log n)，其中n为节点数。与红黑树等平衡树相比，2-3查找树的代码实现更加简单直观。但是，它的常数因子比较大，因此在实际应用中可能会被其他平衡树所取代。

▶️
红黑树（Red-Black Tree）是一种自平衡二叉查找树，它可以保证在最坏情况下基本动态集合操作的时间复杂度为O(log n)，其中n为节点数。红黑树在实际应用中被广泛使用，比如在C++的STL中的set和map数据结构的实现就是基于红黑树。

红黑树满足以下性质：

每个节点要么是红色，要么是黑色。
根节点是黑色的。
每个叶子节点（NIL节点）是黑色的。
如果一个节点是红色的，则它的两个子节点都是黑色的。
对于任意一个节点，从它到达叶子节点的所有路径都包含相同数目的黑色节点。
红黑树通过旋转和颜色变换等操作来保持平衡。具体来说，红黑树的插入和删除操作可以分为以下三个步骤：

插入或删除一个节点，并将它染成红色。
根据红黑树的性质进行旋转和颜色变换，以保持平衡。
将根节点染成黑色，以满足红黑树的性质。
红黑树的平衡操作包括以下两种旋转操作：

左旋操作：对于一个节点的右子树高度大于左子树高度的情况，进行左旋操作。
右旋操作：对于一个节点的左子树的左子树高度大于它的右子树的左子树高度的情况，进行右旋操作。
红黑树的插入、删除、查找等操作的时间复杂度为O(log n)，其中n为红黑树中节点的数量。由于红黑树是一种自平衡树，因此它的性能比普通的二叉查找树更加稳定，尤其适合于需要频繁插入和删除节点的场景。
