Here is a generalized way to solve tree path problems using backtracking:

Initialize your data structures: Usually, you need a list or other data structure to store the final result, and another data structure (often a list) to store the current path.

Depth-First Search: Starting from the root, perform a depth-first search (DFS) on the tree. This involves recursive calls to traverse the left and right subtrees.

Path Update: For each node visited, update the current path. This could involve adding the node's value to the current sum for a path sum problem, or adding the node itself (or its value) to the current path for a path list problem.

Condition Check: Check if the current node/path meets the required conditions. For example, in a path sum problem, check if the path's sum equals the target sum. In a path list problem, you might just check if the current node is a leaf node. If the condition is met, add the current path to your result list.

Backtrack: After visiting a node and its subtrees, you need to revert the change you made to the current path so that you can explore other paths. In Python, this often involves using list.pop() to remove the last node/value added to the path.

⭕️解法一：减法
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def pathSum(self, root, targetSum):
        result = []
        self.dfs(root, targetSum, [], result)
        return result

    def dfs(self, node, remainingSum, path, result):
        if node is None:
            return
        path.append(node.val)
        if remainingSum == node.val and not node.left and not node.right:
            result.append(list(path))
        else:
            self.dfs(node.left, remainingSum - node.val, path, result)
            self.dfs(node.right, remainingSum - node.val, path, result)
        path.pop()  # backtrack to the previous state

⭕️解法二：加法
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def pathSum(self, root, targetSum):
        result = []
        self.dfs(root, 0, targetSum, [], result)
        return result

    def dfs(self, node, currentSum, targetSum, path, result):
        if node is None:
            return
        currentSum += node.val
        path.append(node.val)
        if currentSum == targetSum and not node.left and not node.right:
            result.append(list(path))
        else:
            self.dfs(node.left, currentSum, targetSum, path, result)
            self.dfs(node.right, currentSum, targetSum, path, result)
        path.pop()  # backtrack to the previous state

