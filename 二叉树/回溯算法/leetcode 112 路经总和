⭕️回溯算法
先穷举所有路径
再在路径中找到是否有符合targetSum的路径之和

class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        res = []
        self.dfs(root, [], res)

        for i in range(len(res)):
            if sum(res[i])==targetSum:
                return True
        return False

    def dfs(self, node, path, res):
        if not node:
            return 
        path.append(node.val)
        if not node.left and not node.right:
            res.append(list(path))  # 创建 path 的拷贝
        self.dfs(node.left, path, res) 
        self.dfs(node.right, path, res) 
        path.pop()


⭕️dfs
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False

        # 如果当前节点是叶子节点，并且目标和等于当前节点的值，返回True
        if not root.left and not root.right and targetSum == root.val:
            return True
        
        # 否则，递归地在左子树和右子树中寻找路径
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)

