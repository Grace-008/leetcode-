⭕️暴力解法
#可以使用求子集的方法
#也可以抽象成树形结构

class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        def is_palindrome(s):
            i = 0
            j = len(s) - 1
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True
        
        def dfs(s, start, path):
            nonlocal count  # Use nonlocal to modify the 'count' variable from the outer function

            if start != 0:
                if is_palindrome(path):
                    count = max(count, len(path))

            for i in range(start, len(s)):
                dfs(s, i + 1, path + s[i])
        
        count = 0
        res = []
        dfs(s, 0, '')
        return count

⭕️
  
