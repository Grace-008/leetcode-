⭕️暴力解法

class Solution:
    def trap(self, height: List[int]) -> int:
        #将每一根柱子能接到的雨水累加起来
        #第一根柱子和最后一根柱子接不到水
        #一根柱子能装多少水取决于，该柱子左边最大值和右边最大值的最小值-该柱子的高度
        if len(height)<=2: return 0
        ans=0
        for i in range(1,len(height)-1):
            #求左边最大值
            leftMax = 0
            for j in range(i-1,-1,-1):
                leftMax = max(leftMax,height[j])

            #求右边最大值
            rightMax = 0
            for j in range(i+1,len(height)-1):
                rightMax = max(rightMax,height[j])

            #当前柱子能装的水等于min(leftMax,rightMax)-height[i]
            maxHeight = min(leftMax,rightMax)
            if maxHeight > height[i]:
                ans += maxHeight - height[i]

        return ans
            
            
 ⭕️暴力优化
 ▶️用两个数组来记录左边最大值和右边最大值，从而降低时间复杂度从O（n**2）到O（n）
 class Solution:
    def trap(self, height: List[int]) -> int:
        #将每一根柱子能接到的雨水累加起来
        #第一根柱子和最后一根柱子接不到水
        #一根柱子能装多少水取决于，该柱子左边最大值和右边最大值的最小值-该柱子的高度
        n = len(height)
        if len(height)<=2: return 0

        leftMax = [0] * n
        leftMax[0] = height[0]
        for i in range(n):
            leftMax[i] = max(leftMax[i-1],height[i])

        rightMax = [0] * n
        rightMax[n-1] = height[n-1]
        for i in range(n-2,-1,-1):
            rightMax[i] = max(rightMax[i+1],height[i])
        
        ans=0
        for i in range(1,n-1):

            #当前柱子能装的水等于min(leftMax,rightMax)-height[i]
            maxHeight = min(leftMax[i],rightMax[i])
            if maxHeight > height[i]:
                ans += maxHeight - height[i]

        return ans
            

 ⭕️最优解：双指针：降低空间复杂度
 ▶️因为数组中每个元素只用了一次，可以用两个指针来代替数组
 
 
 class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        if n<=2: return 0
        #记录指针左边最大值，和右边最大值
        leftMax = 0
        rightMax = 0
        #碰撞指针
        left,right=0,n-1
        #存储结果
        ans=0
        while left<right:
            leftMax = max(leftMax,height[left])
            rightMax = max(rightMax,height[right])
            #先计算柱子较低的一方
            if height[left]<height[right]:
                ans += leftMax - height[left]
                left+=1
            else:
                ans += rightMax - height[right]
                right-=1
        return ans
