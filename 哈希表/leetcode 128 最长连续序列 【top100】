⭕️排序算法 时间复杂度O（nlogn）

class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if len(nums)==0:return 0
        nums.sort()
        count=1
        ans=1
        for i in range(1,len(nums)):
            if nums[i]==nums[i-1]:
                continue
            if nums[i]-nums[i-1]==1:
                count+=1
            else:
                ans=max(ans,count)
                count=1
        #如果到最后一个数字还是连续的，此时count还未更新
        return max(ans,count)
        
 ⭕️哈希查找 时间复杂度O（n）
 
 class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if len(nums) < 2:
            return len(nums)

        numSet = set(nums)
        ans=1
        for num in nums:
            if num-1 in numSet:
                continue
            currNum = num
            count=1
            while currNum+1 in numSet:
                count+=1
                currNum+=1
            ans=max(ans,count)
        return ans
        
 
